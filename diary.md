# AHC003

## 2021-05-30

22位まで落ちてた。さすがにね

過去のクエリをランダムに抽出して一から予測し直して、他のクエリをどれだけ正確に当てられるかで

なんか横よりも縦のほうが1回も使っていない辺が多い。探索順の違いによる偏りか？
=> いや別にそうではなかった。コストの分布次第っぽい

xの値を知っていたとして、スムージングの際にその境界を超えないようにしてどれくらいの結果になるか見てみよう
=> 973.498 だった。けっこう上がる

時々過去の履歴から辺の長さの予測をやり直すようにしたら若干良くなって97乗った。
実行時間はだいぶ伸びて1秒超えるくらいになっちゃってるけど



## 2021-05-29

仕事が忙しくて平日全く触れなかった。
まだ13位。1位は974くらいで変わらず。

本方針であるパラメタの推定をやる。

（10ごとに離散化した）Dの値ごとに、[-D, D]をi個合計した確率分布をDPで求めようとしたけどTLE/MLEになる。
中心極限定理で正規分布近似したら十分良さそうだったのでそうすることにした。必ずi>=10だし。
正規化係数を埋め込み。

そうしてもめちゃくちゃ遅いし、過学習しまくって別に精度出てない。パラメタ推定やるのは無理筋か…？



## 2021-05-25

まだ4位か。97超える人がもっとどんどん出てくるかと思ったけど

1位は974くらい。

短い辺が見つかったら、その隣は探ろうとしなくても良い、とかあるかな…？

=> 辺を使った回数を出力してみたら自然とそんな感じになってた

想像以上に短い辺に集中してる。かなり改善の余地少ないな…

> 探索時の未訪問ボーナスは1回も辺を使っていない場合にのみ与えているけど、もっと連続的にしたほうがよいかも

やった。0.1% くらいは上がったか…？　969

> 辺の長さの更新をどうやるか色々試す

訪問回数が少ない辺の方を大きく動かすようにしてみた

若干だけ良くはなってる…のか？？

ひとつながりの縦や横のうち一部だけ使用済みの時、それに隣接する辺は調べなくてもある程度情報が得られているので未訪問ボーナスを減らすとか。


## 2021-05-24

> 中央に近い辺のほうが使う機会が多いので優先して使って精度を上げるようにする

すぐできるのでやった。
…と思ったらAWS上で動かない？

=> `flag?(:debug)` でコンパイル時引数に応じて挙動を切り替えてるつもりだったけど、どうも `:debug` は組み込みのフラグで思い通りの挙動になってなかったっぽい。
`:trace` に変更

特に効果はなかった。


## 2021-05-23

> 予測値を元に最短経路取ってみて、かなり短いようだったらそれを使う、そうでもなかったら未知の辺を重視するようなパスを使う

これをやった。93%手前くらい。


予測された辺の長さを毎ターン周囲の平均に近づけるようにスムージングするのをやったら 96.6% 行っちゃったんだけど…ほんとかなあ

とりあえず提出しとく
=> TLEしちゃった。明示的にflushいるんだっけ…30分待ち

96,718,996,850 暫定1位 最終的な上位は975くらいかなあ

ローカルでは800msくらいかかるのに 373 ms だった。速い

どれくらい強くスムージングを効かせると良いかがm=1とm=2でだいぶ違うから、そいつらを判別したくなる。できるかな…

やること

* 辺の長さの更新をどうやるか色々試す
* m=1,2を区別する、m=2なら切れ目の位置も推定する
* 探索時の未訪問ボーナスは1回も辺を使っていない場合にのみ与えているけど、もっと連続的にしたほうがよいかも
  * どのくらい各辺を使っているのか見てみよう
* 辺の長さを1つずつ焼きなましで更新するのを入れる
  * 辺ごとじゃなくて、直接 `D` の値と区切り位置を行・列ごとに両側から2パターン推定してしまうのがいいのでは
  * m=1 でも両方の長さが一致するだけなので2パターン作っちゃって良い
* 中央に近い辺のほうが使う機会が多いので優先して使って精度を上げるようにする
* スムージングするのに平均取るとき、未使用の辺は除外するとかうまくやった方がいいかもしれない


## 2021-05-22

インタラクティブだった。そんなに絶対スコアの差が付かなさそう

最低点バトルもそれなりに大変そう、というかだいたい同じ問題になりそう

スコアに `2312311` が掛かっているのは、1ケースの最高スコアを1e10にするためっぽい。
（問題文内に書かれててほしい感はある）

即提出している人々の 63,179,310,956 点はフルスコアの63%か。

クエリ間でのスコアへの重みの違いは意外と大きくなくて、

* 1番目のクエリは0.031%の寄与
* 100番目のクエリは0.038%の寄与
* 500番目のクエリは0.085%の寄与
* 1000番目のクエリは0.231%の寄与

くらい。最初と最後で10倍も違わない

テスト実行用にRustコンパイルした結果入れるのだるいからテスター自分で書くか…

とりあえず最短距離を出力してみてどのような形になるか見よう、
と思ったがビジュアライザに最初から出力されてるのか。
マンハッタン距離的に遠回りの経路をとるのが最適なケースは思ったよりかは少なかったけど多いのは多い。

ジャッジから返される距離に1割の誤差が付くのなかなかつらいな

この誤差があるので、一部クエリでは最短にするのを無視して経路の一部を以前のクエリと全く同じにすることで距離特定に全振りする、みたいな方針は無さそう

ジャッジ書いた。Dが小さい方が最短距離を狙って経路取りしないといけないから、自明解のスコアが低いのね。

1クエリでのマンハッタン距離の平均が22-23くらいで、80クエリくらいで平均して各辺を1回ずつ使えるくらいになる。

探索のためにあえて遠回りするような経路を取ることもあるかもしれない。まあバンディット問題ですね

各辺の予測値を更新していって、探索と活用のバランスを取っていくような感じだろうなあ

予測値を元に最短経路取ってみて、かなり短いようだったらそれを使う、そうでもなかったら未知の辺を重視するようなパスを使う、みたいな。
その閾値は進行に伴って変える、とか。

最初の解として、

* 常に予測値を元にした最短経路を使う
* ジャッジから返された値を各辺に分配して予測値を実測値に近づけていく

というのを書いた。これでスコア9割ちょいは出ている。スタートライン感

時々焼きなましで辺の重みを再調整するようなのをやるのかな。
周囲の辺との長さの差が大きくならないという評価も入れて。


